package eu.linksmart.security.communication.impl.asym;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.rmi.RemoteException;
import java.security.Key;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.UnrecoverableKeyException;
import java.security.cert.Certificate;
import java.security.cert.CertificateEncodingException;
import java.security.cert.CertificateException;
import java.security.spec.InvalidKeySpecException;
import java.util.InvalidPropertiesFormatException;
import java.util.Properties;

import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;

import org.apache.log4j.Logger;
import org.apache.xml.security.encryption.EncryptedData;
import org.apache.xml.security.encryption.EncryptedKey;
import org.apache.xml.security.encryption.XMLCipher;
import org.apache.xml.security.keys.KeyInfo;
import org.apache.xml.security.utils.Constants;
import org.apache.xml.security.utils.EncryptionConstants;
import org.w3c.dom.Document;
import org.w3c.dom.Element;

import eu.linksmart.network.HID;
import eu.linksmart.network.Message;
import eu.linksmart.security.communication.CommunicationSecurityManager;
import eu.linksmart.security.communication.CryptoException;
import eu.linksmart.security.communication.SecurityProtocol;
import eu.linksmart.security.communication.VerificationFailureException;
import eu.linksmart.security.communication.impl.asym.util.XMLMessageUtil;
import eu.linksmart.security.communication.util.NonceGenerator;
import eu.linksmart.security.communication.util.impl.NonceGeneratorFactory;
import eu.linksmart.security.cryptomanager.CryptoManager;
import eu.linksmart.security.trustmanager.TrustManager;
import eu.linksmart.utils.Base64;

/**
 * Implementation of {@link SecurityProtocol} interface which
 * uses hybrid encryption based on certificates associated
 * with {@link HID}
 * @author Vinkovits
 *
 */
public class SecurityProtocolAsym implements SecurityProtocol {

	/*
	 * The Log4j logger of this class
	 */
	private static Logger logger = Logger.getLogger(SecurityProtocolAsym.class);

	/**
	 * {@CryptoManager} used to store certificates and keys
	 */
	private CryptoManager cryptoMgr = null;
	/**
	 * {@TrustManager} used to check validity of certificates
	 */
	private TrustManager trustMgr = null;
	/**
	 * The client of this protocol run meaning who started the communication
	 */
	private HID clientHID = null;
	/**
	 * The server of this protocol run meaning who received the request
	 */
	private HID serverHID = null;
	/**
	 * The threshold between 0 and 1 needed for a certificate to be accepted
	 */
	private double trustThreshold;

	/**
	 * NonceGenerator used for creating nonces in this protocol
	 */
	private NonceGenerator nonceGenerator = null;
	/**
	 * Indicates whether the handshake has already been completed successfully
	 */
	private boolean isInitialized = false;
	/**
	 * Indicates whether there has been sent already a message
	 */
	private boolean isStarted = false;
	/**
	 * Indicates whether this party is the client
	 */
	private boolean isClient = false;
	/**
	 * Indicates for a server state machine that it has already sent keys to the client
	 */
	private boolean sentKeyToClient = false;
	/**
	 * Indicates for a client state machine that the acknowledgement has been sent
	 */
	private boolean sentAcknowledgement = false;
	/**
	 * Message which has to be sent when handshake is finished
	 */
	private Message storedMessage = null;
	/**
	 * Nonce generated by this party. Response message has to include signature on it
	 */
	private String generatedNonce;

	public SecurityProtocolAsym(HID clientHID, HID serverHID, CryptoManager cryptoMgr, TrustManager trustMgr, double trustThreshold){
		this.clientHID = clientHID;
		this.serverHID = serverHID;
		this.cryptoMgr = cryptoMgr;
		this.trustMgr = trustMgr;
		this.trustThreshold = trustThreshold;
		nonceGenerator = NonceGeneratorFactory.getInstance();
	}

	public Message startProtocol() throws CryptoException {
		isClient = true;
		isStarted = true;

		Command cmd = new Command(Command.CLIENT_HELLO);	
		cmd.setProperty(Command.CLIENT, clientHID.toString());
		//#NM TODO Mark V.
		if(serverHID!=null)
			cmd.setProperty(Command.SERVER, serverHID.toString());
		generatedNonce = nonceGenerator.getNextNonce();
		cmd.setProperty(Command.CLIENT_NONCE, generatedNonce);
		try {
			return createMessage(CommunicationSecurityManager.SECURITY_PROTOCOL_TOPIC, clientHID, serverHID, cmd);
		} catch (Exception e){
			//this exception cannot happen{
			CryptoException ce = new CryptoException("Error creating initial message");
			ce.initCause(e);
			throw ce;
		}
	}

	public boolean isInitialized() {
		return isInitialized;
	}

	public Message processMessage(Message msg) throws CryptoException, VerificationFailureException, IOException{
		if(!isInitialized){
			//check if protocol is started or this message has to be stored
			if(!isStarted && !msg.getTopic().contentEquals(CommunicationSecurityManager.SECURITY_PROTOCOL_TOPIC)){
				//this is the client side of a handshake
				isClient = true;
				isStarted = true;
				storedMessage = msg;
				return startProtocol();
			} else if(!isStarted && msg.getTopic().contentEquals(CommunicationSecurityManager.SECURITY_PROTOCOL_TOPIC)){
				//this is the server side of a handshake
				isClient = false;
				isStarted = true;
			}

			//get message content
			Command command = getCommand(msg);
			//check whether this is the correct party
			if(!command.get(Command.CLIENT).equals(clientHID.toString()) 
					|| !command.get(Command.SERVER).equals(serverHID.toString())){
				throw new VerificationFailureException("Not appropriate sender or receiver of handshake");
			}

			if(isClient){
				if(!sentAcknowledgement){
					//response from the server which should contain a certificate
					if(Integer.parseInt(command.getProperty("command")) == Command.SERVER_SEND_INFO){
						String signedPayload = command.getProperty(Command.SIGNED_PAYLOAD);

						//verify signature on message
						logger.debug("Verifying message " + signedPayload);
						String verifiedMessage = cryptoMgr.verify(signedPayload);
						logger.debug("Signature of Message from Server verified: " + (verifiedMessage!=null));

						//if signature is valid and nonce matches store certificate
						if (verifiedMessage!=null && verifiedMessage!="" 
							&& generatedNonce.equals(command.getProperty(Command.SERVER_NONCE))) {
							// Convert input String to XML document
							logger.debug("Encrypted message is: " + verifiedMessage);
							//save received certificate
							Certificate cert = XMLMessageUtil.getCertificate(signedPayload);
							String serverKeyidentifier;
							try {
								serverKeyidentifier = cryptoMgr.storePublicKey(Base64.encodeBytes(cert.getEncoded()), "RSA");
							} catch (CertificateEncodingException e) {
								IOException ioe = new IOException("Cannot parse received message!");
								ioe.initCause(e);
								throw ioe;
							}
							saveServerPk(serverKeyidentifier);

						} else {
							logger.debug("Signature or nonce not valid, aborting");
							throw new VerificationFailureException(
									"Signature or nonce from HID: " + serverHID + " not valid!");
						} 

						isInitialized = true;
						//send signature on nonce sent by server
						Command cmd = new Command(Command.CLIENT_ACK);
						cmd.setProperty(Command.CLIENT, clientHID.toString());
						cmd.setProperty(Command.SERVER, serverHID.toString());
						cmd.setProperty(Command.SERVER_NONCE, command.getProperty(Command.SERVER_NONCE));

						//create signature
						ByteArrayOutputStream bos = new ByteArrayOutputStream();
						try {
							cmd.storeToXML(bos, null);
							String signedCommand = cryptoMgr.sign(bos.toString(),null, serverHID.toString());
							cmd.setProperty(Command.SIGNED_PAYLOAD, signedCommand);
							//add stored message if there is one
							if(storedMessage != null){
								try{
									Message protectedMessage = protectMessage(storedMessage);
									cmd.setProperty(Command.APPLICATION_MESSAGE, String.valueOf(protectedMessage.getData()));
									storedMessage = null;
								}catch(Exception e){
									CryptoException ce = new CryptoException("Excaption protecting original message");
									ce.initCause(e);
									throw ce;
								}
							}

							return createMessage(CommunicationSecurityManager.SECURITY_PROTOCOL_TOPIC,
									clientHID,
									serverHID,
									cmd);
						} catch (IOException e) {
							logger.error("Error creating acknowledgment for server",e);
							return null;
						}						
					}
				}
			}else{
				//this is server and client sent request or acknowledgment
				if(!sentKeyToClient && Integer.parseInt(command.getProperty("command")) == Command.CLIENT_HELLO){			
					//create nonce and create command
					Command cmd = new Command(Command.SERVER_SEND_INFO);
					cmd.setProperty(Command.CLIENT, clientHID.toString());
					cmd.setProperty(Command.SERVER, serverHID.toString());
					cmd.setProperty(Command.CLIENT_NONCE, command.getProperty(Command.CLIENT_NONCE));
					generatedNonce = nonceGenerator.getNextNonce();
					cmd.setProperty(Command.SERVER_NONCE, generatedNonce);

					//signing message
					ByteArrayOutputStream bos = new ByteArrayOutputStream();
					cmd.storeToXML(bos, null);
					String signedCommand = cryptoMgr.sign(
							bos.toString(),
							null,
							serverHID.toString());
					cmd.setProperty(Command.SIGNED_PAYLOAD, signedCommand);

					sentKeyToClient = true;
					return createMessage(CommunicationSecurityManager.SECURITY_PROTOCOL_TOPIC,
							serverHID,
							clientHID,
							cmd);
				}else if(sentKeyToClient && Integer.parseInt(command.getProperty("command")) == Command.CLIENT_ACK){
					//if signature on message and certificate are valid go to next state	
					if(verifySignature(command)
							&& verifyCertificate(command)
							&& generatedNonce.equals(command.getProperty(Command.SERVER_NONCE))){					
						isInitialized = true;
						//read application data out of acknowledgment
						if(command.containsKey(Command.APPLICATION_MESSAGE)){
							try{
								String data = command.getProperty(Command.APPLICATION_MESSAGE);
								Message message = new Message("CIPHERTEXT", clientHID, serverHID, data.getBytes());
								message = unprotectMessage(message);
								return message;
							}catch(Exception e){
								CryptoException ce = new CryptoException("Error opening application data sent in handshake");
								ce.initCause(e);
								throw ce;
							}
						}else{
							//handshake finished
							return null;
						}
					}else{
						logger.debug("Signature or nonce not valid, aborting!");
						throw new VerificationFailureException("Received not vlaid signature from HID: " + clientHID);
					}
				}
			}
		}
		return msg;
	}

	public Message protectMessage(Message msg) throws Exception {
		String encryptedMessage = asymEncrypt(String.valueOf(msg.getData()), msg.getReceiverHID().toString());
		msg.setData(encryptedMessage.getBytes());
		return msg;
	}

	public Message unprotectMessage(Message msg) throws Exception {
		String decryptedMessage = asymDecrypt(String.valueOf(msg.getData()));
		msg.setData(decryptedMessage.getBytes());
		return msg;
	}


	/*
	 * Methods needed for the secure session handshake protocol
	 */

	/**
	 * Creates a Message object from a prepared Command object
	 */
	private Message createMessage(String topic, HID senderHID, HID receiverHID, Command command) throws IOException{
		ByteArrayOutputStream bos = new ByteArrayOutputStream();
		byte[] serializedCommand = null;
		try {
			command.storeToXML(bos, null);
			serializedCommand = bos.toByteArray();
		} finally{
			bos.close();
		}

		return new Message(CommunicationSecurityManager.SECURITY_PROTOCOL_TOPIC, clientHID, serverHID, serializedCommand);
	}

	/**
	 * Parses the incoming message's data field into a Command object
	 * @param msg
	 * @return The command included in the data field
	 * @throws IOException If the data is not a command or cannot be parsed
	 */
	private Command getCommand(Message msg) throws IOException{
		Command command = new Command();
		ByteArrayInputStream bis = new ByteArrayInputStream(msg.getData());
		try {
			command.loadFromXML(bis);
		}finally{
			bis.close();
		}

		return command;
	}

	/**
	 * Associates servers's HID with certificate in {@link CryptoManager}
	 * @param identifier
	 */
	private void saveServerPk(String identifier){
		cryptoMgr.addCertificateForHID(serverHID.toString(), identifier);
		logger.debug("Server KEY IDENTIFIER FROM CRYPTOMANAGER: " + identifier + " has been bound to HID: " + serverHID.toString());
	}

	/**
	 * Associates client's HID with certificate in {@link CryptoManager}
	 * @param identifier
	 */
	public void saveClientPk(String identifier){
		cryptoMgr.addCertificateForHID(clientHID.toString(), identifier);
		logger.debug("CLIENT KEY IDENTIFIER FROM CRYPTOMANAGER: " + identifier + " has been bound to HID: " + clientHID.toString());
	}

	/**
	 * Checks using the CryptoManager whether the signature is valid.
	 * @param command Command received from other party
	 * @return true if valid - false if not
	 * @throws IOException 
	 */
	private boolean verifySignature(Command command) throws IOException{
		String signedPayload = command.getProperty(Command.SIGNED_PAYLOAD);

		String verifiedMessage = cryptoMgr.verify(signedPayload);
		logger.debug("Verification of signature. Result: " + (verifiedMessage!=null));
		//if signature is not valid return false
		if (verifiedMessage==null || verifiedMessage.equals("")) {
			return false;
		}

		//Verification of Server/Client/Command fields
		Properties props = new Properties();
		if (verifiedMessage!=null) {
			try {
				props.loadFromXML(new ByteArrayInputStream(verifiedMessage.trim().getBytes()));
			} catch (InvalidPropertiesFormatException e) {
				throw new IOException ("Cannot parse received message!");
			}
		}

		if (!(props.getProperty(Command.SERVER).equals(command.getProperty(Command.SERVER)) 
				&& (props.getProperty(Command.CLIENT).equals(command.getProperty(Command.CLIENT))) 
				&& (props.getProperty(Command.COMMAND).equals(command.getProperty(Command.COMMAND))))) {

			logger.debug("Signed Payload Header Fields differ from unsigned Headers! Aborting!");
			return false;
		}		
		return true;
	}

	/**
	 * Checks using the TrustManager whether the certificate is trusted.
	 * @param command
	 * @param context
	 * @return true if accepted - false if not
	 * @throws IOException 
	 */
	private boolean verifyCertificate(Command command) throws IOException{
		String signedPayload = command.getProperty(Command.SIGNED_PAYLOAD); 		
		Certificate cert = XMLMessageUtil.getCertificate(signedPayload);      		
		Double trust = new Double(0.0);

		if (trustMgr!=null) {
			try{
				String encodedcert = Base64.encodeBytes(cert.getEncoded());
				trust = trustMgr.getTrustValue(encodedcert);
			}catch(RemoteException e){
				IOException ioe = new IOException("Cannot communicate with Trust Manager");
				ioe.initCause(e);
				throw ioe;
			} catch (CertificateEncodingException e) {
				IOException ioe = new IOException("Cannot parse received message!");
				ioe.initCause(e);
				throw ioe;
			}
		}

		logger.debug("Trust in Certificate is: " + trust);

		if (trust < trustThreshold ) {
			return false;
		} else {		
			//as certificate is valid store it in keystore
			try{
				String clientKeyIdentifier = cryptoMgr.storePublicKey(Base64.encodeBytes(cert.getEncoded()), "");
				saveClientPk(clientKeyIdentifier);
			} catch (CertificateEncodingException e) {
				//this exception should not happen as the same method has already invoked once
				IOException ioe = new IOException("Cannot parse received message!");
				ioe.initCause(e);
				throw ioe;
			}
		}
		return true;
	}

	/*
	 * Methods needed for the protection and unprotection of messages
	 */

	/**
	 * Opens the protected message
	 * @param encrData the data element to open
	 * @throws Exception All kinds of exceptions
	 * @throws CryptoException
	 */
	public String asymDecrypt(String encrData) throws Exception, CryptoException {
		String result = "";
		try {
			// Convert input string to XML document
			javax.xml.parsers.DocumentBuilderFactory dbf = javax.xml.parsers.DocumentBuilderFactory.newInstance();
			dbf.setNamespaceAware(true);
			javax.xml.parsers.DocumentBuilder db = dbf.newDocumentBuilder();

			ByteArrayInputStream bis = new ByteArrayInputStream(encrData.getBytes());
			Document document = db.parse(bis);

			// Get the "EncryptedData" element from DOM tree.
			XMLCipher xmlCipher = XMLCipher.getInstance();
			xmlCipher.init(XMLCipher.DECRYPT_MODE, null);
			Element encryptedDataElement = (Element) document.getElementsByTagNameNS(EncryptionConstants.EncryptionSpecNS,
					EncryptionConstants._TAG_ENCRYPTEDDATA).item(0);
			EncryptedData encryptedDataObject = xmlCipher.loadEncryptedData(document, encryptedDataElement);

			// Load the key to be used for decrypting the xml data encryption
			// key.
			Key dek = null;
			if (encryptedDataObject.getKeyInfo().itemEncryptedKey(0) != null) {
				// Retrieve information about the Public Key used to encrypt the
				// DEK
				EncryptedKey ek = encryptedDataObject.getKeyInfo().itemEncryptedKey(0);
				String receiverHID =
					encryptedDataObject.getKeyInfo().getTextFromTextChild().trim();

				// Try to retrieve the corresponding Private Key
				PrivateKey kek = loadKeyDecryptionKey(receiverHID);

				// Set the cipher to "Unwrap" mode and use the Private Key to
				// extract the DEK
				xmlCipher.init(XMLCipher.UNWRAP_MODE, kek);
				dek = xmlCipher.decryptKey(ek, encryptedDataObject.getEncryptionMethod().getAlgorithm());
			}

			/*
			 * The key to be used for decrypting xml data would be obtained from
			 * the keyinfo of the EncrypteData using the kek.
			 */
			xmlCipher.init(XMLCipher.DECRYPT_MODE, dek);

			// replace the encrypted data with decrypted contents in the
			// document.
			xmlCipher.doFinal(document, encryptedDataElement);
			result = document.getElementsByTagName(INSIDE_CONTENT_ELEMENT).item(0).getTextContent();
		} catch (Exception e) {
			if (!(e instanceof VerificationFailureException)) {
				throw e;
			} else {
				throw (VerificationFailureException) e;
			}
		}
		return result;
	}

	public String asymEncrypt(String encstr, String receiverHID) throws Exception {
		String result = "";
		try {
			if (encstr == null) {
				encstr = "";
			}

			// Transform input string to an hydra:InsideProtected-XML document
			DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
			DocumentBuilder db = dbf.newDocumentBuilder();
			Document document = db.newDocument();

			Element rootElement = document.createElementNS(INSIDE_SECURITY_NAMESPACE, INSIDE_PROTECTED_MESSAGE_NAME);

			rootElement.setAttributeNS(Constants.NamespaceSpecNS, "xmlns:linksmart", INSIDE_SECURITY_NAMESPACE);
			Element protectedElement = document.createElementNS(INSIDE_SECURITY_NAMESPACE, INSIDE_PROTECTED_ELEMENT);

			Element contentElement = document.createElementNS(INSIDE_SECURITY_NAMESPACE, INSIDE_CONTENT_ELEMENT);
			contentElement.appendChild(document.createTextNode(encstr));
			protectedElement.appendChild(contentElement);
			rootElement.appendChild(protectedElement);
			document.appendChild(rootElement);

			// Get a public key (KEK) to encrypt the symmetric key (DEK).
			PublicKey kek = loadKeyEncryptionKey(receiverHID);

			// Get a key to encrypt the data (DEK)
			Key dek = loadDataEncryptionKey();

			// Encrypt the DEK using the KEK. This is called "Wrapping"
			String algorithmURI = XMLCipher.RSA_v1dot5;
			logger.debug("retrieving " + XMLCipher.RSA_v1dot5);

			XMLCipher keyCipher = XMLCipher.getInstance(algorithmURI);
			keyCipher.init(XMLCipher.WRAP_MODE, kek);
			EncryptedKey encryptedKey = keyCipher.encryptKey(document, dek);

			// Add the identifier to the message. So the receiver knows which
			// key to
			// use for decryption.
			// encryptedKey.setCarriedName(identifier);

			// Now do the "real" encryption of the content using AES.
			algorithmURI = XMLCipher.AES_128;
			XMLCipher xmlCipher = XMLCipher.getInstance(algorithmURI);
			xmlCipher.init(XMLCipher.ENCRYPT_MODE, dek);

			// Add the "KeyInfo" element to the message so the receiver gets all
			// necessary information
			EncryptedData encryptedData = xmlCipher.getEncryptedData();
			KeyInfo keyInfo = new KeyInfo(document);
			keyInfo.add(encryptedKey);
			keyInfo.addText(receiverHID);
			encryptedData.setKeyInfo(keyInfo);
			xmlCipher.doFinal(document, rootElement, true);

			// Write XML to string
			TransformerFactory factory = TransformerFactory.newInstance();
			Transformer transformer = factory.newTransformer();
			transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, "yes");
			DOMSource source = new DOMSource(document);

			StreamResult sresult = new StreamResult();
			sresult.setOutputStream(new java.io.ByteArrayOutputStream());
			transformer.transform(source, sresult);
			result = (new StringBuffer()).append(sresult.getOutputStream()).toString();

		} catch (Exception e) {
			logger.error("error in encr()", e);
		}
		return result;
	}

	/**
	 * Returns a symmetric secret key that can be used for encryption.
	 * @return Freshly generated symmetric key
	 * @throws KeyStoreException
	 * @throws NoSuchAlgorithmException
	 * @throws CertificateException
	 * @throws IOException
	 * @throws UnrecoverableKeyException
	 * @throws NoSuchProviderException
	 */
	private SecretKey loadDataEncryptionKey() throws KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException,
	UnrecoverableKeyException, NoSuchProviderException {
		String jceAlgorithmName = "DESede";
		KeyGenerator keyGenerator = KeyGenerator.getInstance(jceAlgorithmName);
		SecretKey secretKey = keyGenerator.generateKey();
		return secretKey;

	}

	/**
	 * Private keys for decryption
	 * @param hid
	 * @return PrivateKey object which can be used to open mesasge
	 * @throws NoSuchAlgorithmException
	 * @throws CertificateException
	 * @throws IOException
	 * @throws KeyStoreException
	 * @throws UnrecoverableKeyException
	 */
	private PrivateKey loadKeyDecryptionKey(String hid) throws NoSuchAlgorithmException, CertificateException, IOException, KeyStoreException, UnrecoverableKeyException {
		String identifier = cryptoMgr.getPrivateKeyReference(hid);
		return cryptoMgr.getPrivateKeyByIdentifier(identifier);
	}

	/**
	 * Private keys used for signing
	 * @return PrivateKey object which can be used to sign a message
	 * @throws KeyStoreException
	 * @throws NoSuchAlgorithmException
	 * @throws CertificateException
	 * @throws IOException
	 * @throws UnrecoverableKeyException
	 */
	private PrivateKey loadSigningKey() throws KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException, UnrecoverableKeyException {
		PrivateKey signingKey = cryptoMgr.getPrivateKeyByIdentifier("hydrademo-rsa");
		return signingKey;
	}

	/**
	 * Load the public key of the receiver from the {@link CryptoManager}
	 * @param receiverHID
	 * @return
	 * @throws InvalidKeySpecException
	 * @throws KeyStoreException
	 * @throws NoSuchAlgorithmException
	 * @throws FileNotFoundException
	 * @throws CertificateException
	 */
	private PublicKey loadKeyEncryptionKey(String receiverHID) throws InvalidKeySpecException, KeyStoreException, NoSuchAlgorithmException, FileNotFoundException, CertificateException{
		String identifier = cryptoMgr.getCertificateReference(receiverHID);
		return cryptoMgr.getCertificateByIdentifier(identifier).getPublicKey();
	}
}

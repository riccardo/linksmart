/*
 * In case of German law being applicable to this license agreement, the following warranty and liability terms shall apply:
 *
 * 1. Licensor shall be liable for any damages caused by wilful intent or malicious concealment of defects.
 * 2. Licensor's liability for gross negligence is limited to foreseeable, contractually typical damages.
 * 3. Licensor shall not be liable for damages caused by slight negligence, except in cases 
 *    of violation of essential contractual obligations (cardinal obligations). Licensee's claims for 
 *    such damages shall be statute barred within 12 months subsequent to the delivery of the software.
 * 4. As the Software is licensed on a royalty free basis, any liability of the Licensor for indirect damages 
 *    and consequential damages - except in cases of intent - is excluded.
 *
 * This limitation of liability shall also apply if this license agreement shall be subject to law 
 * stipulating liability clauses corresponding to German law.
 */
/**
 * Copyright (C) 2006-2010
 *                         the HYDRA consortium, EU project IST-2005-034891
 *
 * This file is part of LinkSmart.
 *
 * LinkSmart is free software: you can redistribute it and/or modify
 * it under the terms of the GNU LESSER GENERAL PUBLIC LICENSE
 * version 3 as published by the Free Software Foundation.
 *
 * LinkSmart is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with LinkSmart.  If not, see <http://www.gnu.org/licenses/>.
 */

package eu.linksmart.security.protocols.net;

import eu.linksmart.network.backbone.PipeSyncHandler;
//FIXME for future use interface
import eu.linksmart.network.impl.NetworkManagerApplicationSoapBindingImpl;
import eu.linksmart.security.cryptomanager.CryptoManager;
import eu.linksmart.security.trustmanager.TrustManager;

import eu.linksmart.security.protocols.net.common.CommandQueue;
import eu.linksmart.security.protocols.net.common.MissingSenderCertificateException;
import eu.linksmart.security.protocols.net.impl.SecureSessionControllerImpl;
import eu.linksmart.security.protocols.net.transport.Command;

/**
 * The SecureSessionController interface describes the main interface used when
 * using the Secure Session Protocol. The reference implementation is
 * {@link SecureSessionControllerImpl}, which is a lazy singleton
 * implementation.
 * <p>
 * The generated FSM instances, specifically {@link ClientSocket},
 * {@link ServerSocket}, {@link ClientController}, {@link ServerController} use
 * this interface upon initialization to get associated to a specific session.
 * 
 * @author Stephan Heuser - stephan.heuser@sit.fraunhofer.de
 * 
 */

public interface SecureSessionController {

	/**
	 * Handle a command, encapsulated as a {@link Command} object.
	 * 
	 * @param command
	 *            The to be handled command
	 * @param role
	 *            The role of this entity (server/client), will be derived from 
	 *            {@link PipeSyncHandler}
	 */

	public void handleCommand(Command command, String role);

	/**
	 * Get a waiting session. This is used by the
	 * 
	 * @link{ServerSocket} and @link{ClientSocket} classes. This method will
	 *                    block until a new Sessions available.
	 *                    
	 * @return Session ID of a waiting session
	 */

	public String getWaitingSession();

	/**
	 * Send a new command, encoded as a Command object, via the linksmart Network.
	 * 
	 * @param command
	 *            the to be sent command.
	 */

	public void sendCommand(Command command, String role);

	/**
	 * Get the Command Queue of a session. The Protocol FSM needs a reference to
	 * add new commands here.
	 * 
	 * @param sessionId
	 *            SessionId
	 * @return the corresponding command queue
	 */

	public CommandQueue getCommandQueue(String sessionId);

	/**
	 * Get the Crypto Manager stub used by this SecureSessionController
	 * 
	 * @return The Crypto Manager stub
	 */

	public CryptoManager getCryptoManager();

	/**
	 * Get the Trust Manager stub used by this SecureSessionController
	 * 
	 * @return The Trust Manager stub
	 */

	public TrustManager getTrustManager();

	/**
	 * Set the other parties certificate identifier after a key was exchanged.
	 * 
	 * @param sessionId
	 *            SessionId of the current session
	 * @param identifier
	 *            The certificate identifier of the other party, usually
	 *            generated by Crypto Manager
	 */

	public void setCertificateIdentifier(String sessionId, String identifier);

	/**
	 * Get the certificate / public key Identifier. Basically this is a
	 * synchronous way to start a key exchange between two parties. The
	 * certificate identifier the Crypto Manager generates for the other parties
	 * certificate is returned after the key exchange. Returns null if
	 * certificate exchange failed. Timeout value is 30s, and can be modified
	 * in {@link Consts}
	 * 
	 * @param client
	 *            Client HID
	 * @param server
	 *            Server HID
	 * @return Certificate identifier generated by Crypto Manager
	 * @throws MissingSenderCertificateException 
	 */

	public String getCertificateIdentifier(String client, String server) throws MissingSenderCertificateException;

	/**
	 * Close a active session. This is needed for example when a timeout occurs.
	 * 
	 * @param sessionId
	 *            The sessionId of the to be closed session
	 */

	public void closeSession(String sessionId);

	public NetworkManagerApplicationSoapBindingImpl getNetworkManager();

	public void setTrustThreshold(double trustth);

	double getTrustThreshold();

}

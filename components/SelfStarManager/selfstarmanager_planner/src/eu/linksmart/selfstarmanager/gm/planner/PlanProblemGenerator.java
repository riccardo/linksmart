/*
 * In case of German law being applicable to this license agreement, the following warranty and liability terms shall apply:
 *
 * 1. Licensor shall be liable for any damages caused by wilful intent or malicious concealment of defects.
 * 2. Licensor's liability for gross negligence is limited to foreseeable, contractually typical damages.
 * 3. Licensor shall not be liable for damages caused by slight negligence, except in cases 
 *    of violation of essential contractual obligations (cardinal obligations). Licensee's claims for 
 *    such damages shall be statute barred within 12 months subsequent to the delivery of the software.
 * 4. As the Software is licensed on a royalty free basis, any liability of the Licensor for indirect damages 
 *    and consequential damages - except in cases of intent - is excluded.
 *
 * This limitation of liability shall also apply if this license agreement shall be subject to law 
 * stipulating liability clauses corresponding to German law.
 */
/**
 * Copyright (C) 2006-2010 
 *                         the HYDRA consortium, EU project IST-2005-034891
 *
 * This file is part of LinkSmart.
 *
 * LinkSmart is free software: you can redistribute it and/or modify
 * it under the terms of the GNU LESSER GENERAL PUBLIC LICENSE
 * version 3 as published by the Free Software Foundation.
 *
 * LinkSmart is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with LinkSmart.  If not, see <http://www.gnu.org/licenses/>.
 */
package eu.linksmart.selfstarmanager.gm.planner;

import java.io.PrintStream;
import java.text.StringCharacterIterator;
import java.util.HashSet;
import java.util.Set;

import org.osgi.framework.Bundle;

import eu.linksmart.selfstar.aql.db.ResettableTupleIterator;
import eu.linksmart.selfstar.aql.db.Tuple;

public class PlanProblemGenerator {

	final static String 
		deviceid="DeviceID",
		bundleid="ID",
		STATE="State",
		name="SymbolicName";
	
	private static class BundleRecord{
		String name;
		Long id;
		
		public BundleRecord(String name, Long id){
			this.name=name;
			this.id=id;
		}
	}
	
	/**
	 * This method generates a pddl problem instance, described 
	 * in the pddl domain that includes the following predicates:
	 * 
	 * (:predicates 
     *      (At ?device ?component)
     *      (AvailableAt ?device ?package) ;;don't use predicates derivable from other predicates...
     *      (Provides ?component ?package)
  	 *   (Requires ?component ?package)
     *      (Has ?device ?service)
     *      (BoundTo ?s1 ?s2 ?i)
	 *
	 *
     *      ;; types: 
     *      (Package ?obj)
     *      (Component ?obj)
     *      (Device ?obj)
     *      (Service ?obj)
     *      (Interface ?obj)
     *      
 	 *  ;; states
     *      (initiated ?device)
     *      (started ?service)
     *      (Bound ?s ?i) 
     *                
  	 *	)
	 * @param config
	 */
	private static PrintStream file=System.out;
	
	public static void setFile(PrintStream f){
		file=f;
	}
	
	private static String indent = "";
	private final static void incindent(){
		indent=indent+"\t";
	}
	private final static void decindent(){
		indent=indent.substring(0, indent.length()-1);
	}
	
	private final static void emitln(String s){
		file.print(indent);
		file.println(s);
	}
	private final static void emit(String s){
		file.print(s);
	}
	
	public final static void generatePlan(ResettableTupleIterator initialconfig, ResettableTupleIterator goalstate){
		Set<String>
			devices=new HashSet<String>(5); 
		Set<BundleRecord> 
			services=new HashSet<BundleRecord>(5), 
			components=new HashSet<BundleRecord>(5);
		//file = System.out;
		//CachingIterator rconfig=new CachingIterator(config);
		/* write header, e.g.: 
		 *
		 * (define (problem pb1)
		 *		  (:domain deployment)
		 *		  (:objects C1 C2 D1 client server srvtype P1)
		 */
		emitln(";; Problem instance file auto-generated by PlanProblemGenerator. ");
		emitln("(define (problem pb1)");
		incindent();
		emitln("(:domain deployment)");
		
		// prepare to write objects and types
		for (Tuple t:initialconfig){
			devices.add((String) t.getValue(deviceid));
			Integer state=(Integer)t.getValue(STATE);
			BundleRecord c = new BundleRecord((String) t.getValue(name),(Long)t.getValue(bundleid));
			if (state==Bundle.ACTIVE)
				services.add(c);
			if (state==Bundle.RESOLVED)
				components.add(c);	
		}
		// write objects:
		emitln("(:objects ");
		for(String s:devices)
			emit(makeDeviceName(s)+" ");
		for(BundleRecord r:services)
			emit(makeServiceName(r)+" ");
		for(BundleRecord r:components)
			emit(makeComponentName(r)+" ");
		emit(")\n\n");
		
		// begin init block
		emitln("(:init");
		incindent();
		// write types:
		emitln(";;types");
		for(String s:devices)
			emitln("(Device "+makeDeviceName(s)+")");
		for(BundleRecord r:services)
			emitln("(Service "+makeServiceName(r)+")");
		for(BundleRecord r:components)
			emitln("(Component "+makeComponentName(r)+")");
		
		// write relations:
		emitln(";;relations");
		initialconfig.reset();
		for(Tuple t:initialconfig){
			int state = (Integer)t.getValue("State");
			BundleRecord b = new BundleRecord((String) t.getValue(name),(Long)t.getValue(bundleid));
			String d=(String) t.getValue(deviceid);
			if (state==Bundle.RESOLVED)
				emitln("(At "+makeDeviceName(d)+" "+makeComponentName(b)+")");
			if(state==Bundle.ACTIVE)
				emitln("(Has "+makeDeviceName(d)+" "+makeServiceName(b)+")");

		}
		
		// write states of devices - they're all started since they returned an aql query...
		for(String s:devices)
			emitln("(initiated "+makeDeviceName(s)+")");
		// close init block
		decindent();
		emitln(")");
		
		// write goal block
		writeGoalBlock(goalstate);
		decindent();
		emit(")");
		// close problem instance block.
	}
	
	
	
	private final static void writeGoalBlock(ResettableTupleIterator goalconfig){
		//CachingIterator rgoal=new CachingIterator(goalconfig);
		emitln(";; goal state specification");
		emitln("(:goal ");
		incindent();
		emitln("(and ");
		incindent();
		// write the relations:
		for(Tuple t:goalconfig){
			int state = (Integer)t.getValue("State");
			BundleRecord b = new BundleRecord((String) t.getValue(name),(Long)t.getValue(bundleid));
			String d=(String) t.getValue(deviceid);
			if (state==Bundle.RESOLVED)
				emitln("(At "+makeDeviceName(d)+" "+makeComponentName(b)+")");
			if(state==Bundle.ACTIVE)
				emitln("(Has "+makeDeviceName(d)+" "+makeServiceName(b)+")");
		}		
		// skip writing states of devices - they can't change, and 
		// unless they change there's no need to specify them
		
		//close and-block
		decindent();
		emitln(")");
		// close goal-block
		decindent();
		emitln(")");
		
	}

	public static interface DomainExtensionWriter{
		void addToObjects();
		void addToRelations();
		void addToGoal();
		String getDomainName();
	}
	
	public final static void generateProtocolPlan(ResettableTupleIterator initialstate,
													ResettableTupleIterator goalstate,
													final ResettableTupleIterator initialext, 
													final ResettableTupleIterator goalext){
		DomainExtensionWriter ext = new DomainExtensionWriter(){

			private boolean init=false;
			String tcpint="tcpinterface";
			String udpint="udpinterface";
			String propertynameprefix="httpclientprotocol"; // add client id, eg "24" to change the protocol
			private void init(){
				if(init)
					return;
				
				
				/* 
				 the configuration information pertaining to the protocol domain comes in the form
				 of a set of tuples. Each has (ClientDID, ServerDID, ClientID, Address, Protocol)
				*/
				
				init=true;
			}
			
			@Override
			public void addToObjects() {
				init();
				emit(tcpint+" ");
				emit(udpint+" ");
				emit("udp tcp ");
				for (Tuple t: initialext){
					emit(propertynameprefix+t.getValue("ClientID"));
				}
				initialext.reset();
			}

			@Override
			public void addToRelations() {
				init();
				for (Tuple t: initialext){
					String sname=makeDeviceName((String) t.getValue("ServerDID"));
					String cname=makeDeviceName((String) t.getValue("ClientDID"));
					emitln("(Channel "+cname+" "+sname+")");
					String pname = propertynameprefix+t.getValue("ClientID");
					emitln("(Property "+pname+")");
					emitln("(HasProperty "+cname+" "+pname+")");
					String protocol=(String) t.getValue("Protocol");
					emitln("(PropertyValue "+cname+" "+pname+" "+protocol+")");
					emitln("(Protocol tcp) (Protocol udp)");
					emitln("(Realizes tcpinterface tcp) (Realizes udpinterface udp)");
					emitln("(Provides "+makeServiceName("sc_tcp_protocol")+" "+tcpint+")");
					emitln("(Provides "+makeServiceName("sc_udp_protocol")+" "+udpint+")");
					emitln("(Interface tcpinterface) (Interface udpinterface)");
					emitln("(AvailableAt "+sname+" tcpinterface)");
					emitln("(AvailableAt "+sname+" udpinterface)");
				}
				initialext.reset();
			}

			@Override
			public void addToGoal() {
				init();
				for(Tuple t: goalext){
					String pname = propertynameprefix+t.getValue("ClientID");
					String protocol=(String) t.getValue("Protocol");
					emitln("(PropertyValue "+makeDeviceName((String) t.getValue("ClientDID"))+" "+pname+" "+protocol+")");	
				}
				goalext.reset();
			}

			@Override
			public String getDomainName() {
				return "protocoldomain";
			}
		};
		generateExtendedPlan(initialstate,goalstate,ext);
	}
	
	public final static void generateExtendedPlan(ResettableTupleIterator initialconfig, ResettableTupleIterator goalstate, DomainExtensionWriter ext){
		Set<String>
			devices=new HashSet<String>(5); 
		Set<BundleRecord> 
			services=new HashSet<BundleRecord>(5), 
			components=new HashSet<BundleRecord>(5);
		//file = System.out;
		//CachingIterator rconfig=new CachingIterator(config);
		/* write header, e.g.: 
		 *
		 * (define (problem pb1)
		 *		  (:domain deployment)
		 *		  (:objects C1 C2 D1 client server srvtype P1)
		 */
		emitln(";; Problem instance file auto-generated by PlanProblemGenerator. ");
		emitln("(define (problem protocolproblem)");
		incindent();
		emitln("(:domain "+ext.getDomainName()+")");
		//emitln("(:domain protocoldomain)");
		
		// prepare to write objects and types
		for (Tuple t:initialconfig){
			devices.add((String) t.getValue(deviceid));
			Integer state=(Integer)t.getValue(STATE);
			BundleRecord c = new BundleRecord((String) t.getValue(name),(Long)t.getValue(bundleid));
			if (state==Bundle.ACTIVE)
				services.add(c);
			if (state==Bundle.RESOLVED)
				components.add(c);	
		}
		// write objects:
		emitln("(:objects ");
		for(String s:devices)
			emit(makeDeviceName(s)+" ");
		for(BundleRecord r:services)
			emit(makeServiceName(r)+" ");
		for(BundleRecord r:components)
			emit(makeComponentName(r)+" ");
		ext.addToObjects();
		emit(")\n\n");
		
		// begin init block
		emitln("(:init");
		incindent();
		// write types:
		emitln(";;types");
		for(String s:devices)
			emitln("(Device "+makeDeviceName(s)+")");
		for(BundleRecord r:services)
			emitln("(Service "+makeServiceName(r)+")");
		for(BundleRecord r:components)
			emitln("(Component "+makeComponentName(r)+")");
		
		// write relations:
		emitln(";;relations");
		initialconfig.reset();
		for(Tuple t:initialconfig){
			int state = (Integer)t.getValue("State");
			BundleRecord b = new BundleRecord((String) t.getValue(name),(Long)t.getValue(bundleid));
			String d=(String) t.getValue(deviceid);
			if (state==Bundle.RESOLVED)
				emitln("(At "+makeDeviceName(d)+" "+makeComponentName(b)+")");
			if(state==Bundle.ACTIVE)
				emitln("(Has "+makeDeviceName(d)+" "+makeServiceName(b)+")");

		}
		// write states of devices - they're all started since they returned an aql query...
		for(String s:devices)
			emitln("(initiated "+makeDeviceName(s)+")");
		for(BundleRecord br:services)
			emitln("(started "+makeServiceName(br.name)+")");
		// add objects for extension:
		ext.addToRelations();
		// close init block		
		decindent();
		emitln(")");
		
		// write goal block
		writeExtendedGoalBlock(goalstate, ext);
		decindent();
		emit(")");
		// close problem instance block.
	}

	private final static void writeExtendedGoalBlock(ResettableTupleIterator goalconfig, DomainExtensionWriter ext){
		//CachingIterator rgoal=new CachingIterator(goalconfig);
		emitln(";; goal state specification");
		emitln("(:goal ");
		incindent();
		emitln("(and ");
		incindent();
		// write the relations:
		for(Tuple t:goalconfig){
			int state = (Integer)t.getValue("State");
			BundleRecord b = new BundleRecord((String) t.getValue(name),(Long)t.getValue(bundleid));
			String d=(String) t.getValue(deviceid);
			if (state==Bundle.RESOLVED)
				emitln("(At "+makeDeviceName(d)+" "+makeComponentName(b)+")");
			if(state==Bundle.ACTIVE)
				emitln("(Has "+makeDeviceName(d)+" "+makeServiceName(b)+")");
		}		
		// skip writing states of devices - they can't change, and 
		// unless they change there's no need to specify them
		// adde extensions
		ext.addToGoal();
		//close and-block
		decindent();
		emitln(")");
		// close goal-block
		decindent();
		emitln(")");
		
	}

	
	private final static String makeDeviceName(String id){
		return escapeName("device"+id);
	}
	
	private final static String makeComponentName(BundleRecord r){
		return escapeName("componentid"+r.id+"name"+r.name);
	}
	private final static String makeServiceName(BundleRecord r){
		return makeServiceName(r.name);
	}
	private final static String makeServiceName(String symbolicname){
		return escapeName("servicename"+symbolicname);
	}

	public static String escapeName(String name){
		StringBuilder rval=new StringBuilder(name.length()+10);
		StringCharacterIterator ci = new StringCharacterIterator(name);
		char charac = ci.current();
		while (charac != StringCharacterIterator.DONE){
			if (charac == '.')
				rval.append("01");
			else if (charac == '0')
				rval.append("00");
			else
				rval.append(charac);
			charac = ci.next();
		}
		return rval.toString();
	}
	
	public static String unescapeName(String name){
		StringBuilder rval=new StringBuilder(name.length()+10);
		StringCharacterIterator ci = new StringCharacterIterator(name);
		char charac = ci.current(), cfollow=ci.next();
		while (charac != StringCharacterIterator.DONE){
			if (charac == '0' && cfollow=='1' ){
				rval.append(".");
				charac=ci.next();
				cfollow=ci.next();
			}
			else if (charac == '0' && cfollow=='0'){
				rval.append("0");
				charac=ci.next();
				cfollow=ci.next();
			}
			else{
				rval.append(charac);
				charac = cfollow;
				cfollow = ci.next();
			}
		}
		return rval.toString();
	}
	
}
